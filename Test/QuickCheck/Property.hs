{-# LANGUAGE FlexibleInstances #-}
module Test.QuickCheck.Property where

--------------------------------------------------------------------------
-- imports

import Test.QuickCheck.Gen
import Test.QuickCheck.Arbitrary
import Test.QuickCheck.Text( showErr, putLine )
import Test.QuickCheck.Exception
import Test.QuickCheck.State

import Control.Concurrent
  ( forkIO
  , threadDelay
  , killThread
  , newEmptyMVar
  , takeMVar
  , putMVar
  )

import System.IO
  ( hFlush
  , stdout
  )

import System.Timeout(timeout)
import Data.Maybe

--------------------------------------------------------------------------
-- fixities

infixr 0 ==>
infixr 1 .&.
infixr 1 .&&.
infixr 1 .||.

--------------------------------------------------------------------------
-- * Property and Testable types

type Property = Gen Prop

-- | The class of things which can be tested, i.e. turned into a property.
class Testable prop where
  property :: prop -> Property
  -- Exception handling: the Prop generated by 'property' must never
  -- be _|_ (see the note below about rose trees).
  -- This is guaranteed because every Testable instance calls
  -- property :: Result -> Property or property :: Prop -> Property.
  -- The first never returns _|_ and the second installs an exception handler.

instance Testable () where
  property _ = property rejected

instance Testable Bool where
  property = property . liftBool

instance Testable Result where
  property = return . MkProp . return . return

instance Testable Prop where
  property = liftProp

instance Testable prop => Testable (Gen prop) where
  property mp = do p <- mp; property p

morallyDubiousIOProperty :: Testable prop => IO prop -> Property
morallyDubiousIOProperty = fmap (MkProp . IORose . fmap unProp) . promote . fmap property

instance (Arbitrary a, Show a, Testable prop) => Testable (a -> prop) where
  property f = forAllShrink arbitrary shrink f

--------------------------------------------------------------------------
-- ** Type Prop

newtype Prop = MkProp{ unProp :: Rose (IO Result) }

-- Exception handling.
protect :: (AnException -> a) -> IO a -> IO a
protect f x = either f id `fmap` tryEvaluateIO x

-- The argument to liftProp is user-supplied so may be _|_;
-- to respect our rose tree invariants we have to add exception
-- handling ourselves.
liftProp :: Prop -> Property
liftProp (MkProp r) =
  return . MkProp . IORose $ protect (return . return . exception "Exception") (return r)

-- ** type Rose

-- Invariant: a rose tree must never be _|_.
-- This makes dealing with exceptions much easier for us.
-- This relies on the fact that the 'property' function never returns _|_.
data Rose a = MkRose a [Rose a] | IORose (IO (Rose a))

joinRose :: Rose (Rose a) -> Rose a
joinRose (IORose rs) = IORose (fmap joinRose rs)
joinRose (MkRose (IORose rm) rs) = IORose $ do r <- rm; return (joinRose (MkRose r rs))
joinRose (MkRose (MkRose x ts) tts) =
  -- first shrinks outer quantification; makes most sense
  MkRose x (map joinRose tts ++ ts)
  -- first shrinks inner quantification
  --MkRose x (ts ++ map joinRose tts)

instance Functor Rose where
  fmap f (IORose rs)   = IORose (fmap (fmap f) rs)
  fmap f (MkRose x rs) = MkRose (f x) [ fmap f r | r <- rs ]

instance Monad Rose where
  return x = MkRose x []
  m >>= k  = joinRose (fmap k m)

unpackRose :: Rose (IO Result) -> IO (IO Result, [Rose (IO Result)])
unpackRose rose = either (\e -> (return (exception "Exception" e), [])) id
                  `fmap` tryEvaluateIO (unpack rose)
  where unpack (MkRose x xs) = return (x, xs)
        unpack (IORose m) = m >>= unpack

-- ** Result type

-- We don't allow a Result to be _|_: it should be a 'failed' instead
-- in that case. The protectResult function transforms a possibly-_|_
-- Result into a non-_|_ one by catching any exceptions it throws.
--
-- We also don't allow MkResult { ok = _|_ }; in other words, forcing
-- the result should be enough to force its 'ok' component (and other
-- interesting components). We enforce this by only using 'succeeded',
-- 'failed' and 'rejected' to construct Results.
--
-- An IO Result stored inside a rose tree may be _|_, but unpackRose
-- and mapIOResult take care of protecting them so in most contexts
-- they won't be _|_.

-- | Different kinds of callbacks
data Callback
  = PostTest (State -> Result -> IO ())         -- ^ Called just after a test
  | PostFinalFailure (State -> Result -> IO ()) -- ^ Called with the final failing test-case

-- | The result of a single test.
data Result
  = MkResult
  { ok          :: Maybe Bool     -- ^ result of the test case; Nothing = discard
  , expect      :: Bool           -- ^ indicates what the expected result of the property is
  , reason      :: String         -- ^ a message indicating what went wrong
  , interrupted :: Bool           -- ^ indicates if the test case was cancelled by pressing ^C
  , stamp       :: [(String,Int)] -- ^ the collected values for this test case
  , callbacks   :: [Callback]     -- ^ the callbacks for this test case
  }

result :: Result
result =
  MkResult
  { ok          = undefined
  , expect      = True
  , reason      = ""
  , interrupted = False
  , stamp       = []
  , callbacks   = []
  }

exception :: String -> AnException -> Result
exception msg err = failed{ reason = msg ++ ": '" ++ showErr err ++ "'",
                            interrupted = isInterrupt err }

protectResult :: IO Result -> IO Result
protectResult m = protect (exception "Exception") m

succeeded :: Result 
succeeded = result{ ok = Just True }

failed :: Result
failed = result{ ok = Just False }

rejected :: Result
rejected = result{ ok = Nothing }

--------------------------------------------------------------------------
-- ** Lifting and mapping functions

liftBool :: Bool -> Result
liftBool True = succeeded
liftBool False = failed { reason = "Falsifiable" }

mapResult :: Testable prop => (Result -> Result) -> prop -> Property
mapResult f = mapIOResult (fmap f)

mapIOResult :: Testable prop => (IO Result -> IO Result) -> prop -> Property
mapIOResult f = mapRoseIOResult (fmap (f . protectResult))

mapBottomUp :: Testable prop => (IO (IO Result, [Rose (IO Result)]) -> Rose (IO Result)) -> prop -> Property
mapBottomUp f = mapRoseIOResult g
  where g r = f (fmap h (unpackRose r))
        h (m, rs) = (m, map g rs)

-- f here has to be total (rose tree invariant).
mapRoseIOResult :: Testable prop => (Rose (IO Result) -> Rose (IO Result)) -> prop -> Property
mapRoseIOResult f = mapProp (\(MkProp t) -> MkProp (f t))

mapProp :: Testable prop => (Prop -> Prop) -> prop -> Property
mapProp f = fmap f . property

--------------------------------------------------------------------------
-- ** Property combinators

-- | Changes the maximum test case size for a property.
mapSize :: Testable prop => (Int -> Int) -> prop -> Property
mapSize f p = sized ((`resize` property p) . f)

-- | Shrinks the argument to property if it fails. Shrinking is done
-- automatically for most types. This is only needed when you want to
-- override the default behavior.
shrinking :: Testable prop =>
             (a -> [a])  -- ^ 'shrink'-like function.
          -> a           -- ^ The original argument
          -> (a -> prop) -> Property
shrinking shrinker x0 pf = fmap (MkProp . joinRose . fmap unProp) (promote (props x0))
 where
  props x =
    MkRose (property (pf x)) [ props x' | x' <- shrinker x ]

-- | Disables shrinking for a property altogether.
noShrinking :: Testable prop => prop -> Property
noShrinking = mapRoseIOResult f
  where f (MkRose mres _ts) = MkRose mres []
        f (IORose rm) = IORose (fmap f rm)

-- | Adds a callback
callback :: Testable prop => Callback -> prop -> Property
callback cb = mapResult (\res -> res{ callbacks = cb : callbacks res })

-- | Prints a message to the terminal after the last failure of a property.
whenFailPrint :: Testable prop => String -> prop -> Property
whenFailPrint s =
  callback $ PostFinalFailure $ \st _res ->
    putLine (terminal st) s

-- | Performs an 'IO' action after the last failure of a property.
whenFail :: Testable prop => IO () -> prop -> Property
whenFail m =
  callback $ PostFinalFailure $ \_st _res ->
    m

-- | Performs an 'IO' action every time a property fails. Thus,
-- if shrinking is done, this can be used to keep track of the 
-- failures along the way.
whenFail' :: Testable prop => IO () -> prop -> Property
whenFail' m =
  callback $ PostTest $ \_st res ->
    if ok res == Just False
      then m
      else return ()

-- | Modifies a property so that it is expected to fail for some test cases.
expectFailure :: Testable prop => prop -> Property
expectFailure = mapResult (\res -> res{ expect = False })

-- | Attaches a label to a property. This is used for reporting
-- test case distribution.
label :: Testable prop => String -> prop -> Property
label s = classify True s

-- | Labels a property with a value:
--
-- > collect x = label (show x)
collect :: (Show a, Testable prop) => a -> prop -> Property
collect x = label (show x)

-- | Conditionally labels test case.
classify :: Testable prop => 
            Bool    -- ^ @True@ if the test case should be labelled.
         -> String  -- ^ Label.
         -> prop -> Property
classify b s = cover b 0 s

-- | Checks that at least the given proportion of the test cases belong
-- to the given class.
cover :: Testable prop => 
         Bool   -- ^ @True@ if the test case belongs to the class.
      -> Int    -- ^ The required percentage (0-100) of test cases.
      -> String -- ^ Label for the test case class.
      -> prop -> Property
cover b n s = mapResult $ \res ->
        case b of
         True  -> res{ stamp  = (s,n) : stamp res }
         False -> res

-- | Implication for properties: The resulting property holds if
-- the first argument is 'False', or if the given property holds.
(==>) :: Testable prop => Bool -> prop -> Property
False ==> _ = property ()
True  ==> p = property p

-- | Considers a property failed if it does not complete within
-- the given number of microseconds.
within :: Testable prop => Int -> prop -> Property
within n = mapBottomUp race
 where
  race m = IORose $ do
    do x <- timeout n $ do { x <- m; return $! x }
       case x of
         Nothing -> return (return (return failed { reason = "Timeout" }))
         Just (m, rs) -> do
           y <- fmap (fromMaybe failed { reason = "Timeout" })
                     (timeout n $ do { x <- m; return $! x })
           return (MkRose (return y) rs)

-- | Explicit universal quantification: uses an explicitly given
-- test case generator.
forAll :: (Show a, Testable prop)
       => Gen a -> (a -> prop) -> Property
forAll gen pf =
  gen >>= \x ->
    whenFailPrint (show x) $
      property (pf x)

-- | Like 'forAll', but tries to shrink the argument for failing test cases.
forAllShrink :: (Show a, Testable prop)
             => Gen a -> (a -> [a]) -> (a -> prop) -> Property
forAllShrink gen shrinker pf =
  gen >>= \x ->
    shrinking shrinker x $ \x' ->
      whenFailPrint (show x') $
        property (pf x')

(.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
p1 .&. p2 =
  arbitrary >>= \b ->
    whenFailPrint (if b then "LHS" else "RHS") $
      if b then property p1 else property p2

(.&&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
p1 .&&. p2 =
  conjoin [("(False .&&. _)",property p1), ("(_ .&&. False)",property p2)]

conjoin :: Testable prop => [(String,prop)] -> Property
conjoin ps = 
  do roses <- sequence [ do MkProp rose <- property (whenFailPrint s p)
                            return rose
                       | (s,p) <- ps
                       ]
     return (MkProp (conj roses))
 where
  conj [] =
    MkRose (return succeeded) []

  conj (IORose ioRose : ps) =
    IORose (do p <- ioRose; return (conj (p:ps)))

  conj (MkRose ioResult roses : ps) =
    IORose (do result <- ioResult
               if ok result == Just True
                 then return (conj ps)
                 else return (MkRose (return result) roses))

(.||.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
p1 .||. p2 = disjoin [("(False .||. _):",property p1), ("(_ .||. False):",property p2)]

disjoin :: Testable prop => [(String,prop)] -> Property
disjoin ps = 
  do roses <- sequence [ do MkProp rose <- property (whenFailPrint s p)
                            return rose
                       | (s,p) <- ps
                       ]
     return (MkProp (foldr disj (MkRose (return failed) []) roses))
 where
  disj :: Rose (IO Result) -> Rose (IO Result) -> Rose (IO Result)
  disj p q =
    do ioResult1 <- p
       ioResult2 <- q
       return (do result1 <- ioResult1
                  if ok result1 == Just True
                    then return result1
                    else do result2 <- ioResult2
                            return (result1 >>> result2))

  result1 >>> result2 =
    result2
    { reason      = if null (reason result2) then reason result1 else reason result2
    , interrupted = interrupted result1 || interrupted result2
    , stamp       = stamp result1 ++ stamp result2
    , callbacks   = callbacks result1 ++ callbacks result2
    }

--------------------------------------------------------------------------
-- the end.
